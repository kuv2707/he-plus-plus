package utils

import (
	"fmt"
	"math/rand"
	// "sort"
	"testing"
)
// generated by gemini

// --- Helper: Tree Validator ---
// This function strictly enforces all Red-Black Tree invariants.
func (rbt *RBTreeMap[K, V]) validate() error {
	if rbt.root == nil {
		return fmt.Errorf("root is nil (should be nilNode or valid node)")
	}

	// Rule 1: Root must be black (unless tree is empty/nilNode)
	if rbt.root != rbt.nilNode && rbt.root.color == RED {
		return fmt.Errorf("root is RED")
	}

	// Rule 2: Verify BST property (In-order traversal is sorted)
	// Rule 3: Red nodes cannot have Red children
	// Rule 4: Black Height consistency
	_, err := rbt.validateNode(rbt.root)
	return err
}

// Returns (blackHeight, error)
func (rbt *RBTreeMap[K, V]) validateNode(n *RBNode[K, V]) (int, error) {
	if n == rbt.nilNode {
		return 1, nil // Nil nodes are black leaves
	}

	// Check BST Property (Locally)
	if n.children[LEFT] != rbt.nilNode {
		if rbt.comparator(n.children[LEFT].key, n.key) >= 0 {
			return 0, fmt.Errorf("BST violation: Left child %v >= Node %v", n.children[LEFT].key, n.key)
		}
	}
	if n.children[RIGHT] != rbt.nilNode {
		if rbt.comparator(n.key, n.children[RIGHT].key) >= 0 {
			return 0, fmt.Errorf("BST violation: Right child %v <= Node %v", n.children[RIGHT].key, n.key)
		}
	}

	// Check Red-Red conflict
	if rbt.isRed(n) {
		if rbt.isRed(n.children[LEFT]) || rbt.isRed(n.children[RIGHT]) {
			return 0, fmt.Errorf("Red violation at node %v: Red node has Red child", n.key)
		}
	}

	// Recurse
	bhLeft, err := rbt.validateNode(n.children[LEFT])
	if err != nil {
		return 0, err
	}
	bhRight, err := rbt.validateNode(n.children[RIGHT])
	if err != nil {
		return 0, err
	}

	// Check Black Height Consistency
	if bhLeft != bhRight {
		return 0, fmt.Errorf("Black height mismatch at node %v: Left=%d, Right=%d", n.key, bhLeft, bhRight)
	}

	// Calculate current black height
	bh := bhLeft
	if !rbt.isRed(n) {
		bh++
	}
	return bh, nil
}

// --- Tests ---

func TestBasicInsert(t *testing.T) {
	tree := MakeRBTreeMap[int, string]()
	tree.setComparator(func(a, b int) int {
		if a < b {
			return -1
		}
		if a > b {
			return 1
		}
		return 0
	})

	keys := []int{10, 20, 30, 15, 25, 5, 1}
	for _, k := range keys {
		tree.Insert(k, fmt.Sprintf("val-%d", k))
		if err := tree.validate(); err != nil {
			t.Fatalf("Validation failed after inserting %d: %v", k, err)
		}
	}

	if tree.Size() != len(keys) {
		t.Errorf("Expected size %d, got %d", len(keys), tree.Size())
	}
}

func TestUpdate(t *testing.T) {
	tree := MakeRBTreeMap[int, string]()
	tree.setComparator(func(a, b int) int { return a - b }) // Simplified comparator for ints

	tree.Insert(10, "old")
	tree.Insert(10, "new")

	if tree.Size() != 1 {
		t.Errorf("Size should be 1 after update, got %d", tree.Size())
	}

	// Access directly via internal map to verify
	if node, exists := tree.keyNode[10]; !exists || node.value != "new" {
		t.Errorf("Value was not updated correctly")
	}
}

func TestBasicDelete(t *testing.T) {
	tree := MakeRBTreeMap[int, int]()
	tree.setComparator(func(a, b int) int {
		if a < b {
			return -1
		}
		if a > b {
			return 1
		}
		return 0
	})

	// Insert 1 to 20
	for i := 1; i <= 20; i++ {
		tree.Insert(i, i)
	}

	// Delete odd numbers
	for i := 1; i <= 20; i += 2 {
		tree.Delete(i)
		if err := tree.validate(); err != nil {
			t.Fatalf("Validation failed after deleting %d: %v", i, err)
		}
	}

	if tree.Size() != 10 {
		t.Errorf("Expected size 10, got %d", tree.Size())
	}

	// Ensure deleted keys are gone from map
	if _, exists := tree.keyNode[1]; exists {
		t.Error("Deleted key 1 still exists in internal map")
	}
}

func TestRandomFuzz(t *testing.T) {
	// Fuzzy testing with random operations
	tree := MakeRBTreeMap[int, int]()
	tree.setComparator(func(a, b int) int {
		if a < b {
			return -1
		}
		if a > b {
			return 1
		}
		return 0
	})

	// Use a standard Go map as "Ground Truth"
	truth := make(map[int]int)

	// 1000 Random operations
	for i := range 1000 {
		key := rand.Intn(500)
		op := rand.Intn(3) // 0,1=Insert, 2=Delete

		if op < 2 {
			// INSERT
			val := rand.Int()
			tree.Insert(key, val)
			truth[key] = val
		} else {
			// DELETE
			tree.Delete(key)
			delete(truth, key)
		}

		// Validation every step (expensive but safe)
		// For larger sets, move this outside the loop
		if err := tree.validate(); err != nil {
			t.Fatalf("Structure invalid after op %d (Key: %d): %v", i, key, err)
		}
	}

	// Verify Contents match Ground Truth
	if tree.Size() != len(truth) {
		t.Errorf("Size mismatch. Tree: %d, Map: %d", tree.Size(), len(truth))
	}

	for k, v := range truth {
		// Use internal map for fast lookup
		node, exists := tree.keyNode[k]
		if !exists {
			t.Errorf("Key %d exists in map but missing in Tree", k)
		}
		if node.value != v {
			t.Errorf("Value mismatch for key %d", k)
		}
	}
}

func TestLargeScaleSortedInsert(t *testing.T) {
	// RBT worst case: inserting sorted data
	tree := MakeRBTreeMap[int, int]()
	tree.setComparator(func(a, b int) int {
		if a < b {
			return -1
		}
		if a > b {
			return 1
		}
		return 0
	})

	count := 5000
	for i := 0; i < count; i++ {
		tree.Insert(i, i)
	}

	if err := tree.validate(); err != nil {
		t.Fatalf("Validation failed after large sorted insert: %v", err)
	}

	// Deleting from root (middle of balanced tree roughly)
	tree.Delete(count / 2)
	if err := tree.validate(); err != nil {
		t.Fatalf("Validation failed after deleting root-area node")
	}
}
